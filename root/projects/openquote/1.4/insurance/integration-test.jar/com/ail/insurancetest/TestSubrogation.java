/* Copyright Applied Industrial Logic Limited 2002. All rights reserved. */
/*
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc., 51 
 * Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

package com.ail.insurancetest;

import static org.junit.Assert.*;

import java.security.Principal;
import java.sql.Connection;
import java.sql.Statement;
import java.util.Hashtable;
import java.util.Iterator;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import com.ail.core.Core;
import com.ail.core.CoreUser;
import com.ail.core.PreconditionException;
import com.ail.core.VersionEffectiveDate;
import com.ail.core.XMLString;
import com.ail.core.configure.AbstractConfigurationLoader;
import com.ail.core.configure.Configuration;
import com.ail.core.configure.ConfigurationHandler;
import com.ail.core.configure.ConfigurationOwner;
import com.ail.core.configure.JDBCConfigurationLoader;
import com.ail.financial.Currency;
import com.ail.financial.CurrencyAmount;
import com.ail.insurance.claim.Claim;
import com.ail.insurance.claim.ClaimSection;
import com.ail.insurance.claim.ClaimStatus;
import com.ail.insurance.claim.PaymentType;
import com.ail.insurance.claim.Recovery;
import com.ail.insurance.claim.RecoveryType;
import com.ail.insurance.subrogation.SubrogationBean;
import com.ail.insurance.subrogation.makearecovery.MakeARecoveryCommand;
import com.ail.insurance.subrogation.makearecovery.MakeARecoveryService;

/**
 * The tests defined here exercise the Core system's factory.
 * They use the Core class as an EntryPoint or core client would.
 * Note: These tests assume that the JDBCConfigurationLoader is being used.
 */
public class TestSubrogation implements CoreUser, ConfigurationOwner {
    private static final long serialVersionUID = 6326694128299920621L;

    private boolean setup=false;
	private Core core=null;
	private VersionEffectiveDate versionEffectiveDate=null;
	private String TestNamespace="TESTNAMESPACE";
	private String configurationNamespace=TestNamespace;

	/**
     * Tidy up (delete) the testdata generated by this set of tests.
     */
	private void tidyUpTestData() {
        try {
			JDBCConfigurationLoader jload=(JDBCConfigurationLoader)AbstractConfigurationLoader.loadLoader();
			Connection con=jload.openConnection();
		    Statement st=con.createStatement();
			st.execute("DELETE FROM config WHERE NAMESPACE='"+TestNamespace+"'");
			st.close();
	        con.close();
		}
        catch(Exception e) {
            fail("failed to clear testnamespace from table");
        }
    }

	private void oneTimeSetUp() {
		if (setup==false) {
			try {
				// Reset the core's configuration
		        core=new Core(this);
				core.resetConfiguration();
				versionEffectiveDate=new VersionEffectiveDate();

				// Reset the Rainbow bean's configuration
				SubrogationBean b=new SubrogationBean();
		        b.ejbCreate();
		        b.resetConfiguration();

                new MakeARecoveryService().resetConfiguration();

				setup=true;
			}
            catch(Exception e) {
                fail("Exception caught in oneTimeSetUp:"+e);
            }
        }
    }

    /**
     * Sets up the fixture (run before every test).
     * Get an instance of Core, and delete the testnamespace from the config table.
     */
	@Before
	public void setUp() {
        oneTimeSetUp();
        core=new Core(this);
        this.resetConfiguration();
        ConfigurationHandler.resetCache();
		versionEffectiveDate=new VersionEffectiveDate();
    }

    /**
     * Tears down the fixture (run after each test finishes)
     */
	@After
    public void tearDown() {
		tidyUpTestData();
    }

	/**
     * Method demanded by the CoreUser interface.
     * @return A date to use to selecte the corrent version of config info.
     */
    public VersionEffectiveDate getVersionEffectiveDate() {
		return versionEffectiveDate;
    }

    /**
     * Method demanded by the CoreUser interface.
     * @return Caller's security principal - may be null.
     */
    public Principal getSecurityPrincipal() {
        return null;
    }

    /**
     * Method demanded by the ConfigurationOwner interface.
	 * @param config Configuration to use from now on.
     */
    public void setConfiguration(Configuration config) {
		core.setConfiguration(config);
    }

	/**
     * Method demanded by the ConfigurationOwner interface.
	 * @return The current configuration (at versionEffectiveDate).
     */
    public Configuration getConfiguration() {
		return core.getConfiguration();
    }

	/**
     * Method demanded by the ConfigurationOwner interface.
	 * @return The configuration namespace we're using
     */
    public String getConfigurationNamespace() {
		return configurationNamespace;
    }

	/**
     * Method demanded by the ConfigurationOwner interface.
     */
    public void resetConfiguration() {
		String defConfig="<configuration timeout='1000' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'>"+
    					    "<name>Default TestReference Configuration</name>"+
							"<version>$Revision: 1.2 $</version>"+
                            "<types>"+
								"<type name='MakeARecoveryService' builder='ClassBuilder' key='com.ail.core.command.EJBAccessor'>"+
									"<parameter name='Factory'>org.jnp.interfaces.NamingContextFactory</parameter>"+
									"<parameter name='Protocol'>jnp</parameter>"+
                                    "<parameter name='Server'>localhost</parameter>"+
                                    "<parameter name='PortNumber'>1099</parameter>"+
									"<parameter name='RemoteMethod'>makeARecovery</parameter>"+
			                        "<parameter name='JndiName'>SubrogationBean</parameter>"+
        						"</type>"+
				                "<type name='MakeARecovery' builder='ClassBuilder' key='com.ail.insurance.subrogation.makearecovery.MakeARecoveryCommand'>"+
			                        "<parameter name='Accessor'>MakeARecoveryService</parameter>"+
								"</type>"+
                                "<type name='Claim' builder='ClassBuilder' key='com.ail.insurance.claim.Claim'/>"+
                                "<type name='ClaimSection' builder='ClassBuilder' key='com.ail.insurance.claim.ClaimSection'/>"+
                     		"</types>"+
                    	"</configuration>";

		try {
			Configuration config=(Configuration)core.fromXML(Configuration.class, new XMLString(defConfig));
			setConfiguration(config);
		}
        catch(Exception e) {
            core.logError("Failed to reset configuration:"+e);
        }
    }

	/**
     * Ensure that the MakeARecoveryEntryPoint handles bad arguments
     * correctly.
     * <ol>
     * <li>Invoke the entry point with no arguments set.</li>
     * <li>Fail if any exception other than PreconditionException is thrown, or if no exception is thrown.</li>
     * <li>Invoke the entry point with only the claim are set.<li>
     * <li>Fail if any exception other than PreconditionException is thrown, or if no exception is thrown.</li>
     * </ol>
     */
    @Test
    public void testInvokeMakeARecoveryBadArgs() {
        // try invoking the entry point with no args...
		try {
			MakeARecoveryCommand command=core.newCommand(MakeARecoveryCommand.class);
            command.invoke();
            fail("No exception thrown when null args were passed");
        }
		catch(PreconditionException e) {
            // ignore this, it is what we want
        }
        catch(Exception e) {
            fail("Unexpected exception:"+e);
        }

        // try invoking with only the claim arg...
        try {
            MakeARecoveryCommand command=core.newCommand(MakeARecoveryCommand.class);
            command.setClaim((Claim)core.newType("Claim"));
            command.invoke();
            fail("No exception thrown when null args were passed");
        }
        catch(PreconditionException e) {
			// ignore this, it is what we want
        }
        catch(Exception e) {
            fail("Unexpected exception:"+e);
        }
    }

    /**
     * Ensure that MakeARecovery responds correctly to a set to correct parameters.
     */
    @Test
    public void testGoodInvocation() {
        try {
            // create the command objects.
            MakeARecoveryCommand command=core.newCommand(MakeARecoveryCommand.class);

            // populate the command with valid arguments.
            // First we have to create a claim, as it would appear when ready to
            // accept a recovery (i.e. after firstNotificationOfLoss, firstNotification
            // ofSubrogationPotential.
            Claim claim=(Claim)core.newType("Claim");
            claim.setSubrogationPotential(true);
            claim.setClaimStatus(ClaimStatus.OPEN);

            // Add a section to the claim
            ClaimSection section1=(ClaimSection)core.newType("ClaimSection");
            section1.setID("SECTION1");
            section1.setEstimatedReserve(new CurrencyAmount(1000.0, Currency.USD));
            section1.setTotalRecovered(new CurrencyAmount(0.0, Currency.USD));
            section1.setOutstandingClaim(new CurrencyAmount(600.0, Currency.USD));
            claim.getClaimSections().add(section1);

            // Add another section to the claim
            ClaimSection section2=(ClaimSection)core.newType("ClaimSection");
            section2.setID("SECTION2");
            section2.setEstimatedReserve(new CurrencyAmount(50000.00, Currency.USD));
            section2.setTotalRecovered(new CurrencyAmount(0.00, Currency.USD));
            section2.setOutstandingClaim(new CurrencyAmount(1000.00, Currency.USD));
            claim.getClaimSections().add(section2);

            // Set the claim totals
            claim.setOutstandingTotal(new CurrencyAmount(51000.00, Currency.USD));
            claim.setTotalRecovered(new CurrencyAmount(0.00, Currency.USD));

            // Define the monies that have been recovered
            Hashtable<String,CurrencyAmount> recoveries=new Hashtable<String,CurrencyAmount>();
            recoveries.put("SECTION1", new CurrencyAmount(280.00, Currency.USD));
            recoveries.put("SECTION2", new CurrencyAmount(200.00, Currency.USD));

            // Populate the command's arguments
            command.setClaim(claim);
            command.setPaymentType(PaymentType.SUBROGATION_CONSULTANT);
            command.setRecoveryType(RecoveryType.CONTRIBUTION_FROM_INSURED);
            command.setRecoveryMade(recoveries);
            command.setSource("From the insured");
            command.setReason("Following a demand");

            // Execute the command
            command.invoke();

            // Now check the results, first that the claim's totals have been modified
            assertTrue("50520.0==command.getClaim().getOutstandingTotal().getAmount().doubleValue()", 50520.0==command.getClaim().getOutstandingTotal().getAmount().doubleValue());
            assertTrue("480.0==command.getClaim().getTotalRecovered().getAmount().doubleValue()", 480.0==command.getClaim().getTotalRecovered().getAmount().doubleValue());

            // Check that the sections totals have been modified
            ClaimSection section=command.getClaim().getClaimSectionByID("SECTION1");
            assertNotNull(section);
            assertTrue("720.0==section.getEstimatedReserve().getAmount().doubleValue()", 720.0==section.getEstimatedReserve().getAmount().doubleValue());
            assertTrue("280.0==section.getTotalRecovered().getAmount().doubleValue()", 280.0==section.getTotalRecovered().getAmount().doubleValue());
            assertTrue("320.0==section.getOutstandingClaim().getAmount().doubleValue()", 320.0==section.getOutstandingClaim().getAmount().doubleValue());

            // Check that the recovery has been added to the section.
            Iterator<Recovery> it=section.getRecoveries().iterator();
            // there should be exactly one record
            assertTrue(it.hasNext());
            Recovery recovery=it.next();
            assertTrue(!it.hasNext());

            assertNotNull(recovery);
            assertTrue(PaymentType.SUBROGATION_CONSULTANT.equals(recovery.getPaymentType()));
            assertTrue(RecoveryType.CONTRIBUTION_FROM_INSURED.equals(recovery.getRecoveryType()));
            assertEquals("Following a demand", recovery.getReason());
            assertEquals("From the insured", recovery.getRecoveredFrom());
            assertNotNull(recovery.getRecoveredDate());
        }
        catch(Exception e) {
            fail("Caught unexpected exception: "+e);
        }
    }
}
